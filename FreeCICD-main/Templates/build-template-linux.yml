# templates/build-template-linux.yml
parameters:
  buildProjectName: ''
  buildCsProjectPath: ''
  buildPublishArgs: ''
  buildNamespace: ''

steps:
- checkout: BuildRepo
  displayName: "Check out BuildRepo"
  
- task: PowerShell@2
  displayName: "Create Source Snapshot (.zip)"
  inputs:
    targetType: inline
    script: |
      $src = "$(Build.SourcesDirectory)"
      $outDir = "$(Build.ArtifactStagingDirectory)"
      $zipPath = Join-Path $outDir "${{ parameters.buildProjectName }}.source.$(Build.BuildNumber).zip"

      Write-Host "Zipping source from: $src"
      Write-Host "Destination zip:     $zipPath"

      # Exclude common folders not needed in a source snapshot
      $exclude = @('.git', '.github', '.vs', 'bin', 'obj', 'node_modules')

      $items = Get-ChildItem -LiteralPath $src -Force
      $includeItems = $items | Where-Object { $exclude -notcontains $_.Name }

      if (-not (Test-Path $outDir)) {
        New-Item -ItemType Directory -Path $outDir -Force | Out-Null
      }

      # Compress only the selected items at the root of the repo
      if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
      Compress-Archive -Path $includeItems.FullName -DestinationPath $zipPath -Force

      Write-Host "Created source snapshot at: $zipPath"

- task: PublishBuildArtifacts@1
  displayName: "Publish Source Snapshot Artifact"
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/${{ parameters.buildProjectName }}.source.$(Build.BuildNumber).zip'
    ArtifactName: '${{ parameters.buildProjectName }}.SourceSnapshot'

- script: |
    echo "=== Building and Publishing ==="
    echo "Project Name: ${{ parameters.buildProjectName }}"
    echo "CSProj: ${{ parameters.buildCsProjectPath }}"
    echo "Publish Args: ${{ parameters.buildPublishArgs }}"
    echo "Build Namespace: ${{ parameters.buildNamespace }}"
  displayName: "Echo Build Parameters"

# NOTE: Host-side SDK installs removed - all builds now happen inside Docker container.
# This saves ~30-60 seconds per build.

# NOTE: We used to do a DotNetCoreCLI restore here on the host.
# Now restore happens inside the Linux container, so that step is removed.

- task: PowerShell@2
  displayName: "Switch on buildNamespace (set pipeline variable)"
  inputs:
    targetType: inline
    script: |
      $depNamespace = "${{ parameters.buildNamespace }}"
      Write-Host "Checking if given a namespace..."
      switch ($depNamespace) {
        '' {
          Write-Host "Switch says: We were not given a namespace."
          Write-Host "##vso[task.setvariable variable=DO_BUILD_INFO]False"
        }
        default {
          Write-Host "Switch says: We were given a namespace."
          Write-Host "##vso[task.setvariable variable=DO_BUILD_INFO]True"
        }
      }
      Write-Host "Finished switch-based test."

- task: PowerShell@2
  displayName: "Hack it during cicd example 1: Generate DataController.Hello.cs"
  condition: eq(variables['DO_BUILD_INFO'], 'True')
  inputs:
    targetType: "inline"
    script: |
      # Define the C# code template with a placeholder for the namespace
      $codeTemplate = @"
      using Microsoft.AspNetCore.Mvc;

      namespace {{Namespace}}.Controllers;

      public partial class DataController
      {
          [HttpGet]
          [Route("~/api/Data/Hello")]
          public ActionResult<string> Hello([FromQuery] string world)
          {
              var result = "hello " + world;
              return Ok(result);
          }
      }
      "@

      # Replace the placeholder {{Namespace}} with the actual namespace provided
      $finalCode = $codeTemplate -replace '{{Namespace}}', '${{ parameters.buildNamespace }}'

      # Compute the project folder from the buildCsProjectPath parameter (remove the csproj file)
      $csprojFullPath = Join-Path -Path '$(Build.SourcesDirectory)' -ChildPath '${{ parameters.buildCsProjectPath }}'
      $projectFolder = [System.IO.Path]::GetDirectoryName($csprojFullPath)
      $controllersFolder = Join-Path -Path $projectFolder -ChildPath 'Controllers'

      # Define the output file path inside the Controllers folder
      $outputFilePath = Join-Path -Path $controllersFolder -ChildPath 'DataController.Hello.cs'

      # Ensure the Controllers folder exists
      if (-not (Test-Path -Path $controllersFolder)) {
          Write-Output "Controllers folder not found. Creating folder at '$controllersFolder'."
          New-Item -ItemType Directory -Path $controllersFolder -Force | Out-Null
      }

      # Write the final code to the specified output path
      try {
          $finalCode | Out-File -FilePath $outputFilePath -Encoding utf8 -Force
          Write-Output "DataController.Hello.cs successfully created at '$outputFilePath' with namespace '${{ parameters.buildNamespace }}'."
      }
      catch {
          Write-Error "Failed to write DataController.Hello.cs. Error: $_"
          exit 1
      }

      # Read the contents of the generated file and write it to the console
      try {
          $fileContent = Get-Content -Path $outputFilePath -Raw
          Write-Output "---- Contents of DataController.Hello.cs ----"
          Write-Output $fileContent
      }
      catch {
          Write-Error "Failed to read DataController.Hello.cs. Error: $_"
          exit 1
      }

- task: PowerShell@2
  displayName: "Hack it during cicd example 2: Generate DataController.BuildInfo.cs with Build Info"
  condition: eq(variables['DO_BUILD_INFO'], 'True')
  inputs:
    targetType: "inline"
    script: |
      # Define the C# code template with placeholders for the variables
      $codeTemplate = @"
      using Microsoft.AspNetCore.Mvc;

      namespace {{Namespace}}.Controllers;

      public partial class DataController
      {
          public static readonly string PipelineStartTime       = @"{{PipelineStartTime}}";
          public static readonly string BuildId                 = @"{{BuildId}}";
          public static readonly string BuildNumber             = @"{{BuildNumber}}";
          public static readonly string BuildUri                = @"{{BuildUri}}";
          public static readonly string DefinitionName          = @"{{DefinitionName}}";
          public static readonly string DefinitionId            = @"{{DefinitionId}}";
          public static readonly string TeamProject             = @"{{TeamProject}}";
          public static readonly string RepositoryName          = @"{{RepositoryName}}";
          public static readonly string RepositoryUri           = @"{{RepositoryUri}}";
          public static readonly string RepositoryId            = @"{{RepositoryId}}";
          public static readonly string RepositoryProvider      = @"{{RepositoryProvider}}";
          public static readonly string RepositoryLocalPath     = @"{{RepositoryLocalPath}}";
          public static readonly string SourceBranch            = @"{{SourceBranch}}";
          public static readonly string SourceBranchName        = @"{{SourceBranchName}}";
          public static readonly string SourceVersion           = @"{{SourceVersion}}";
          public static readonly string SourceVersionAuthor     = @"{{SourceVersionAuthor}}";
          public static readonly string SourceVersionMessage    = @"{{SourceVersionMessage}}";
          public static readonly string RequestedFor            = @"{{RequestedFor}}";
          public static readonly string RequestedForEmail       = @"{{RequestedForEmail}}";
          public static readonly string AgentId                 = @"{{AgentId}}";
          public static readonly string AgentName               = @"{{AgentName}}";
          public static readonly string AgentMachineName        = @"{{AgentMachineName}}";
          public static readonly string AgentOS                 = @"{{AgentOS}}";
          public static readonly string AgentVersion            = @"{{AgentVersion}}";
          public static readonly string BuildProjectName        = @"{{BuildProjectName}}";
          public static readonly string BuildNamespace          = @"{{BuildNamespace}}";
          public static readonly string DotNetVersion           = @"{{DotNetVersion}}";
          public static readonly string SourcesDirectory        = @"{{SourcesDirectory}}";

          [HttpGet]
          [Route("~/api/Data/BuildInfo")]
          public ActionResult<object> GetBuildInfo()
          {
              return new
              {
                  PipelineStartTime,
                  BuildId,
                  BuildNumber,
                  BuildUri,
                  DefinitionName,
                  DefinitionId,
                  TeamProject,
                  RepositoryName,
                  RepositoryUri,
                  RepositoryId,
                  RepositoryProvider,
                  RepositoryLocalPath,
                  SourceBranch,
                  SourceBranchName,
                  SourceVersion,
                  SourceVersionAuthor,
                  SourceVersionMessage,
                  RequestedFor,
                  RequestedForEmail,
                  AgentId,
                  AgentName,
                  AgentMachineName,
                  AgentOS,
                  AgentVersion,
                  BuildProjectName,
                  BuildNamespace,
                  DotNetVersion,
                  SourcesDirectory
              };
          }
      }
      "@

      $finalCode = $codeTemplate `
          -replace '{{Namespace}}', '${{ parameters.buildNamespace }}' `
          -replace '{{PipelineStartTime}}', $env:SYSTEM_PIPELINESTARTTIME `
          -replace '{{BuildId}}', $env:BUILD_BUILDID `
          -replace '{{BuildNumber}}', $env:BUILD_BUILDNUMBER `
          -replace '{{BuildUri}}', $env:BUILD_BUILDURI `
          -replace '{{DefinitionName}}', $env:BUILD_DEFINITIONNAME `
          -replace '{{DefinitionId}}', $env:SYSTEM_DEFINITIONID `
          -replace '{{TeamProject}}', $env:SYSTEM_TEAMPROJECT `
          -replace '{{RepositoryName}}', $env:BUILD_REPOSITORY_NAME `
          -replace '{{RepositoryUri}}', $env:BUILD_REPOSITORY_URI `
          -replace '{{RepositoryId}}', $env:BUILD_REPOSITORY_ID `
          -replace '{{RepositoryProvider}}', $env:BUILD_REPOSITORY_PROVIDER `
          -replace '{{RepositoryLocalPath}}', $env:BUILD_REPOSITORY_LOCALPATH `
          -replace '{{SourceBranch}}', $env:BUILD_SOURCEBRANCH `
          -replace '{{SourceBranchName}}', $env:BUILD_SOURCEBRANCHNAME `
          -replace '{{SourceVersion}}', $env:BUILD_SOURCEVERSION `
          -replace '{{SourceVersionAuthor}}', $env:BUILD_SOURCEVERSIONAUTHOR `
          -replace '{{SourceVersionMessage}}', $env:BUILD_SOURCEVERSIONMESSAGE `
          -replace '{{RequestedFor}}', $env:BUILD_REQUESTEDFOR `
          -replace '{{RequestedForEmail}}', $env:BUILD_REQUESTEDFOREMAIL `
          -replace '{{AgentId}}', $env:AGENT_ID `
          -replace '{{AgentName}}', $env:AGENT_NAME `
          -replace '{{AgentMachineName}}', $env:AGENT_MACHINENAME `
          -replace '{{AgentOS}}', $env:AGENT_OS `
          -replace '{{AgentVersion}}', $env:AGENT_VERSION `
          -replace '{{BuildProjectName}}', $env:CI_BUILD_PROJECTNAME `
          -replace '{{BuildNamespace}}', $env:CI_BUILD_NAMESPACE `
          -replace '{{DotNetVersion}}', $env:CI_DOTNETVERSION_DEV `
          -replace '{{SourcesDirectory}}', $env:BUILD_SOURCESDIRECTORY

      $csprojFullPath = Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath '${{ parameters.buildCsProjectPath }}'
      $projectFolder = [System.IO.Path]::GetDirectoryName($csprojFullPath)
      $controllersFolder = Join-Path -Path $projectFolder -ChildPath 'Controllers'
      $outputFilePath = Join-Path -Path $controllersFolder -ChildPath 'DataController.BuildInfo.cs'

      if (-not (Test-Path -Path $controllersFolder)) {
          Write-Output "Controllers folder not found. Creating folder at '$controllersFolder'."
          New-Item -ItemType Directory -Path $controllersFolder -Force | Out-Null
      }

      try {
          $finalCode | Out-File -FilePath $outputFilePath -Encoding utf8 -Force
          Write-Output "DataController.BuildInfo.cs successfully created at '$outputFilePath'."
      }
      catch {
          Write-Error "Failed to write DataController.BuildInfo.cs. Error: $_"
          exit 1
      }

      try {
          $fileContent = Get-Content -Path $outputFilePath -Raw
          Write-Output "---- Contents of DataController.BuildInfo.cs ----"
          Write-Output $fileContent
      }
      catch {
          Write-Error "Failed to read DataController.BuildInfo.cs. Error: $_"
          exit 1
      }
      
# ---- Build Debian 12 Slim .NET SDK base image if it's not already present ----
# This base image contains the .NET SDK, Node.js, and other build tools.
# It's cached on the build agent and only rebuilt if manually deleted.
- task: PowerShell@2
  displayName: "Build Debian 12 Slim .NET SDK base image (if missing)"
  inputs:
    targetType: inline
    script: |
      $imageName = "local-debian-dotnet-sdk:latest"
      Write-Host "Checking if Docker image '$imageName' exists..."

      $imageExists = $false
      try {
        docker image inspect $imageName 2>$null | Out-Null
        if ($LASTEXITCODE -eq 0) {
          $imageExists = $true
        }
      }
      catch {
        $imageExists = $false
      }

      if ($imageExists) {
        Write-Host "Image '$imageName' already exists. Skipping build."
        return
      }

      Write-Host "Image '$imageName' not found. Building new image..."

      $dockerfilePath = Join-Path "$(Agent.TempDirectory)" "debian-dotnet-sdk.Dockerfile"

      $dockerfileContent = @"
      FROM debian:12-slim

      # Install prerequisites (slim image needs more base packages)
      RUN apt-get update && apt-get install -y --no-install-recommends \
          wget \
          gnupg \
          ca-certificates \
          curl \
          apt-transport-https \
          unzip \
          zip \
          git \
          locales \
          libicu72 \
          libssl3 \
          && rm -rf /var/lib/apt/lists/*

      # Install Microsoft package repository for Debian 12
      RUN wget https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O /tmp/packages-microsoft-prod.deb \
          && dpkg -i /tmp/packages-microsoft-prod.deb \
          && rm /tmp/packages-microsoft-prod.deb \
          && apt-get update \
          && apt-get install -y --no-install-recommends \
              dotnet-sdk-8.0 \
              dotnet-sdk-9.0 \
              dotnet-sdk-10.0 \
          && rm -rf /var/lib/apt/lists/*

      # Install Node.js 20 for front-end / Blazor builds
      RUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - \
          && apt-get update \
          && apt-get install -y --no-install-recommends nodejs \
          && rm -rf /var/lib/apt/lists/*

      # Optional: install PowerShell (if you ever want pwsh inside the container)
      RUN apt-get update \
          && apt-get install -y --no-install-recommends powershell \
          && rm -rf /var/lib/apt/lists/*

      ENV DOTNET_ROOT=/usr/share/dotnet
      ENV PATH="`$PATH:`$DOTNET_ROOT"
      ENV DOTNET_CLI_TELEMETRY_OPTOUT=1
      ENV DOTNET_NOLOGO=1
      ENV DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1

      WORKDIR /src
      "@

      $dockerfileContent | Set-Content -Path $dockerfilePath -Encoding UTF8

      Write-Host "Dockerfile written to $dockerfilePath"

      docker build -t $imageName -f $dockerfilePath "$(Agent.TempDirectory)"

      if ($LASTEXITCODE -ne 0) {
        Write-Error "Docker build failed with exit code $LASTEXITCODE"
        exit $LASTEXITCODE
      }

      Write-Host "Successfully built image '$imageName'."

# ---- Build project with Docker layer caching for fast restores ----
# This uses a multi-stage Dockerfile where:
#   Stage 1 (restore): Copies only .sln/.slnx/.csproj files, then runs dotnet restore
#                      This layer is CACHED until project files change
#   Stage 2 (build):   Copies all source, builds the project
#   Stage 3 (publish): Publishes the project
#   Stage 4 (output):  Extracts just the published files using BuildKit --output
- task: PowerShell@2
  displayName: "Build + Publish with Docker layer caching"
  inputs:
    targetType: inline
    script: |
      $env:DOCKER_BUILDKIT = "1"
      
      $src         = "$(Build.SourcesDirectory)"
      $artifacts   = "$(Build.ArtifactStagingDirectory)"
      $projectPath = "${{ parameters.buildCsProjectPath }}"
      $projectName = "${{ parameters.buildProjectName }}"
      $publishArgs = "${{ parameters.buildPublishArgs }}"
      $baseImage   = "local-debian-dotnet-sdk:latest"

      Write-Host "=== Build Configuration ==="
      Write-Host "Source:      $src"
      Write-Host "Artifacts:   $artifacts"
      Write-Host "Project:     $projectPath"
      Write-Host "ProjectName: $projectName"
      Write-Host "PublishArgs: $publishArgs"

      # Extract configuration from publishArgs (default to Release if not specified)
      $configuration = "Release"
      if ($publishArgs -match '--configuration\s+(\w+)') {
        $configuration = $Matches[1]
      }
      elseif ($publishArgs -match '-c\s+(\w+)') {
        $configuration = $Matches[1]
      }
      Write-Host "Configuration: $configuration"

      # Find all solution and project files for the restore layer
      # These are copied first so the restore layer can be cached
      Write-Host "`n=== Discovering project files for restore layer ==="
      
      $projectFiles = Get-ChildItem -Path $src -Recurse -Include "*.sln","*.slnx","*.csproj" -File | 
        Where-Object { $_.FullName -notmatch '\\(bin|obj|node_modules)\\' }
      
      # Generate COPY commands that preserve directory structure
      $copyCommands = @()
      foreach ($file in $projectFiles) {
        $relativePath = $file.FullName.Substring($src.Length + 1).Replace('\', '/')
        $relativeDir = [System.IO.Path]::GetDirectoryName($relativePath).Replace('\', '/')
        
        if ($relativeDir) {
          $copyCommands += "COPY `"$relativePath`" `"$relativeDir/`""
        } else {
          $copyCommands += "COPY `"$relativePath`" `"./`""
        }
        Write-Host "  Found: $relativePath"
      }

      $copyProjectFilesBlock = $copyCommands -join "`n"

      # Create .dockerignore to speed up context transfer
      $dockerignoreContent = @"
      .git
      .github
      .vs
      **/bin
      **/obj
      **/node_modules
      **/*.user
      **/*.suo
      "@
      $dockerignoreContent | Set-Content -Path (Join-Path $src ".dockerignore") -Encoding UTF8

      # Generate the multi-stage Dockerfile
      $dockerfilePath = Join-Path $src "Dockerfile.build"

      # Extract just the publish args without output (we handle output separately)
      $publishArgsClean = $publishArgs -replace '--output\s+\S+', '' -replace '-o\s+\S+', ''

      $dockerfileContent = @"
      # syntax=docker/dockerfile:1.4

      # ============================================
      # Stage 1: Restore (cached if .csproj/.sln unchanged)
      # ============================================
      FROM $baseImage AS restore
      WORKDIR /src

      # Copy only project/solution files first (layer cache optimization)
      $copyProjectFilesBlock

      # Restore dependencies (this layer is cached until project files change)
      RUN dotnet restore "$projectPath"

      # ============================================
      # Stage 2: Build
      # ============================================
      FROM restore AS build
      WORKDIR /src

      # Copy everything else (source code, generated files, etc.)
      COPY . .

      # Build the project with the same configuration as publish
      RUN dotnet build "$projectPath" --no-restore --configuration $configuration

      # ============================================
      # Stage 3: Publish
      # ============================================
      FROM build AS publish

      RUN dotnet publish "$projectPath" --no-build $publishArgsClean --output /app/publish

      # ============================================
      # Stage 4: Output (for extraction)
      # ============================================
      FROM scratch AS output
      COPY --from=publish /app/publish /
      "@

      $dockerfileContent | Set-Content -Path $dockerfilePath -Encoding UTF8
      
      Write-Host "`n=== Generated Dockerfile ==="
      Get-Content $dockerfilePath | Write-Host

      # Ensure output directory exists
      $outputPath = Join-Path $artifacts "publish\$projectName"
      if (-not (Test-Path $outputPath)) {
        New-Item -ItemType Directory -Path $outputPath -Force | Out-Null
      }

      # Build and extract output directly to artifacts folder using BuildKit
      Write-Host "`n=== Building with Docker BuildKit ==="
      
      $buildArgs = @(
        "build"
        "--file", $dockerfilePath
        "--target", "output"
        "--output", "type=local,dest=$outputPath"
        "--progress=plain"
        $src
      )

      Write-Host "Running: docker $($buildArgs -join ' ')"
      
      & docker @buildArgs

      if ($LASTEXITCODE -ne 0) {
        Write-Error "Docker build failed with exit code $LASTEXITCODE"
        exit $LASTEXITCODE
      }

      # Cleanup temporary files
      Remove-Item -Path $dockerfilePath -Force -ErrorAction SilentlyContinue
      Remove-Item -Path (Join-Path $src ".dockerignore") -Force -ErrorAction SilentlyContinue

      Write-Host "`n=== Build completed successfully ==="
      Write-Host "Published output: $outputPath"
      Get-ChildItem $outputPath | ForEach-Object { Write-Host "  $($_.Name)" }

# ---- Ensure 7-Zip is installed for fast zipping ----
- task: PowerShell@2
  displayName: "Ensure 7-Zip is installed"
  inputs:
    targetType: inline
    script: |
      $7zPath = "C:\Program Files\7-Zip\7z.exe"
      
      if (Test-Path $7zPath) {
        Write-Host "7-Zip is already installed at $7zPath"
        & $7zPath | Select-Object -First 2
        return
      }
      
      Write-Host "7-Zip not found. Installing via Chocolatey..."
      
      # Check if Chocolatey is installed
      $chocoPath = Get-Command choco -ErrorAction SilentlyContinue
      if (-not $chocoPath) {
        Write-Host "Chocolatey not found. Installing Chocolatey first..."
        Set-ExecutionPolicy Bypass -Scope Process -Force
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
        Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
        
        # Refresh environment
        $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
      }
      
      # Install 7-Zip
      Write-Host "Installing 7-Zip..."
      choco install 7zip -y --no-progress
      
      if ($LASTEXITCODE -ne 0) {
        Write-Error "Failed to install 7-Zip via Chocolatey"
        exit $LASTEXITCODE
      }
      
      # Verify installation
      if (Test-Path $7zPath) {
        Write-Host "7-Zip installed successfully"
        & $7zPath | Select-Object -First 2
      }
      else {
        Write-Error "7-Zip installation completed but executable not found at $7zPath"
        exit 1
      }

# ---- Zip published output using 7-Zip with maximum performance ----
- task: PowerShell@2
  displayName: "Zip Published Output (7-Zip Turbo)"
  inputs:
    targetType: inline
    script: |
      $publishFolder = "$(Build.ArtifactStagingDirectory)\publish\${{ parameters.buildProjectName }}"
      $zipPath = "$(Build.ArtifactStagingDirectory)\${{ parameters.buildProjectName }}.1.$(Build.BuildNumber).zip"
      $7zPath = "C:\Program Files\7-Zip\7z.exe"
      
      if (-not (Test-Path $publishFolder)) {
        Write-Error "Publish folder not found: $publishFolder"
        Exit 1
      }
      
      # Get system info for optimal threading
      $cpuCount = (Get-CimInstance -ClassName Win32_Processor).NumberOfLogicalProcessors
      Write-Host "Detected $cpuCount logical processors"
      
      # Count files and get total size for logging
      $files = Get-ChildItem -Path $publishFolder -Recurse -File
      $fileCount = $files.Count
      $totalSizeMB = [math]::Round(($files | Measure-Object -Property Length -Sum).Sum / 1MB, 2)
      Write-Host "Zipping $fileCount files ($totalSizeMB MB) from: $publishFolder"
      Write-Host "Destination: $zipPath"
      
      $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
      
      if (Test-Path $7zPath) {
        Write-Host "Using 7-Zip with maximum performance settings..."
        Write-Host "  - Format: Standard ZIP (compatible with Expand-Archive)"
        Write-Host "  - Compression: Store (mx=0) - no compression for max speed"
        Write-Host "  - Threads: $cpuCount (all available cores)"
        Write-Host "  - Memory: Large dictionary for better throughput"
        
        # 7-Zip arguments for maximum speed:
        # -tzip     = Standard ZIP format (Windows compatible)
        # -mx=0     = Store mode (no compression, fastest possible)
        # -mmt=$cpu = Use all CPU threads
        # -mfb=256  = Fast bytes (higher = faster for store mode)
        # -bso1     = Show output
        # -bsp1     = Show progress
        $7zArgs = @(
          "a"                      # Add to archive
          "-tzip"                  # ZIP format
          "-mx=0"                  # Store mode (no compression)
          "-mmt=$cpuCount"         # Use all CPU threads
          "-bso1"                  # Standard output
          "-bsp1"                  # Progress output
          $zipPath                 # Output file
          "$publishFolder\*"       # Input files
        )
        
        Write-Host "Running: 7z $($7zArgs -join ' ')"
        & $7zPath @7zArgs
        
        if ($LASTEXITCODE -ne 0) {
          Write-Error "7-Zip failed with exit code $LASTEXITCODE"
          exit $LASTEXITCODE
        }
      }
      else {
        Write-Warning "7-Zip not found at $7zPath, falling back to Compress-Archive (slower)..."
        Compress-Archive -Path "$publishFolder\*" -DestinationPath $zipPath -Force -CompressionLevel Fastest
      }
      
      $stopwatch.Stop()
      $elapsed = $stopwatch.Elapsed.TotalSeconds
      
      # Report results
      $zipSize = (Get-Item $zipPath).Length
      $zipSizeMB = [math]::Round($zipSize / 1MB, 2)
      $speedMBps = [math]::Round($totalSizeMB / $elapsed, 2)
      
      Write-Host ""
      Write-Host "=== Zip Complete ==="
      Write-Host "  Source:      $totalSizeMB MB ($fileCount files)"
      Write-Host "  Output:      $zipSizeMB MB"
      Write-Host "  Time:        $([math]::Round($elapsed, 2)) seconds"
      Write-Host "  Speed:       $speedMBps MB/s"
      Write-Host "  Zip Path:    $zipPath"

- task: PublishBuildArtifacts@1
  displayName: "Publish Zip Artifact"
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/${{ parameters.buildProjectName }}.1.$(Build.BuildNumber).zip'
    ArtifactName: '${{ parameters.buildProjectName }}.Artifact'

- template: clean-workspace-template.yml