# templates/gather-iis-info-template.yml

# Duplicated from Dan's script, but this produces a different format like we had in the previous Octopus script.
parameters:
  - name: artifactName
    type: string
    default: 'IISInfo'

steps:
  - task: PowerShell@2
    displayName: 'Gather IIS Information'
    inputs:
      targetType: 'inline'
      script: |
        #try {
        #    Import-Module WebAdministration
        #} catch {
        #    Write-Error "Failed to load the WebAdministration module. Exiting."
        #    exit 1
        #}

        #Add-Type -AssemblyName 'Microsoft.Web.Administration'
        Add-Type -Path "C:\Windows\System32\inetsrv\Microsoft.Web.Administration.dll"
        $iis = New-Object Microsoft.Web.Administration.ServerManager

        function Get-AppPools($pools) {
            $output = @()
            foreach ($pool in $pools) {
                $output += [PSCustomObject]@{
                    Name = $pool.Name
                    ManagedRuntimeVersion = $pool.ManagedRuntimeVersion
                    IdentityType = $pool.ProcessModel.IdentityType.ToString()
                    Username = $pool.ProcessModel.UserName
                    Password = $pool.ProcessModel.Password
                }
            }
            return $output
        }

        function CollectionItems($collection) {
            $output = @{}
            foreach ($item in $collection) {
                $output[$item.Name] = $item.Value
            }
            return $output
        }

        function CollectionItem($collection, $item) {
            if ($collection.ContainsKey($item)) {
                return $collection[$item]
            }
            return $null
        }

        function RenderAppPool($appPools, $appPoolName) {
            $output = @()
            $p = "│                "
            $output += "$p Name: $appPoolName"
            $thisAppPool = $appPools | Where-Object { $_.Name -eq $appPoolName }
            if ($thisAppPool) {
                if ($thisAppPool.IdentityType) { $output += "$p IdentityType: $($thisAppPool.IdentityType)" }
                if ($thisAppPool.ManagedRuntimeVersion) { $output += "$p ManagedRuntimeVersion: $($thisAppPool.ManagedRuntimeVersion)" }
                if ($thisAppPool.Username) { $output += "$p Username: $($thisAppPool.Username)" }
                #if ($thisAppPool.Password) { $output += "$p Password: *** (See the Credentials App)" }
                if ($thisAppPool.Password) { $output += "$p Password: $($thisAppPool.Password)" }
            }
            return $output
        }

        function RenderSite($site, $appPools) {
            $output = @()
            $output += "│ SITE: $($site.Name)"
            if ($site.Bindings.Count -gt 0) {
                $output += "│    BINDINGS:"
                foreach ($binding in $site.Bindings) {
                    $sslInfo = ""
                    if ($binding.CertificateHash) {
                        $hash = [BitConverter]::ToString($binding.CertificateHash).Replace("-", "")
                        $sslInfo = " (SSL CERT Hash:$hash"
                        if ($binding.CertificateStoreName) {
                            $sslInfo += ", Store:$($binding.CertificateStoreName)"
                        }
                        $sslInfo += ")"
                    }
                    $output += "│        $($binding.Protocol.ToUpper()) - $($binding.BindingInformation)$sslInfo"
                }
            }

            if ($site.Applications.Count -gt 0) {
                $output += "│    APPLICATIONS:"
                foreach ($app in $site.Applications | Sort-Object Path) {
                    $output += "│         $($app.Path)"
                    $physicalPath = $app.VirtualDirectories["/"].PhysicalPath
                    $output += "│            Physical Path: $physicalPath"

                    $attributes = CollectionItems $app.Attributes
                    $appPool = CollectionItem $attributes 'applicationPool'
                    $output += "│            Application Pool:"
                    $output += RenderAppPool $appPools $appPool
                    $output += "│"
                }
            }

            return $output
        }

        $appPools = Get-AppPools $iis.ApplicationPools
        $sites = $iis.Sites

        if ($sites -and $sites.Count -gt 0) {
            $output = @()
            $artifact = @()
            
            foreach ($site in $sites | Sort-Object @{ Expression = { if ($_.Name -eq 'Default Web Site') { 0 } else { 1 } } }, Name) {
                $siteName = $site.Name
                if ($siteName.Length -gt 88) {
                    $siteName = $siteName.Substring(0, 88)
                }

                $output += "┌"
                $output += "│"
                $output += "│ $siteName"
                $output += "│"
                $output += "├"
                $output += RenderSite $site $appPools
                $output += "└"
            }

            $longest = ($output | Measure-Object -Property Length -Maximum).Maximum

            foreach ($line in $output) {
                if ($line.StartsWith("┌")) {
                    Write-Output "$line$([string]::new('─', ($longest + 1 - $line.Length)))┐"
                    $artifact += "$line$([string]::new('─', ($longest + 1 - $line.Length)))┐"
                } elseif ($line.StartsWith("├")) {
                    Write-Output "$line$([string]::new('─', ($longest + 1 - $line.Length)))┤"
                    $artifact += "$line$([string]::new('─', ($longest + 1 - $line.Length)))┤"
                } elseif ($line.StartsWith("└")) {
                    Write-Output "$line$([string]::new('─', ($longest + 1 - $line.Length)))┘"
                    $artifact += "$line$([string]::new('─', ($longest + 1 - $line.Length)))┘"
                } else {
                    Write-Output "$line$([string]::new(' ', ($longest - $line.Length))) │"
                    $artifact += "$line$([string]::new(' ', ($longest - $line.Length))) │"
                }
            }

            # Write the artifact
            $outputFile = "${{ parameters.artifactName }}.txt"
            $outputPath = Join-Path "$(Build.ArtifactStagingDirectory)" $outputFile
            $artifact | Out-File -FilePath $outputPath -Encoding UTF8
        }

  - task: PublishBuildArtifacts@1
    displayName: "Publish IIS Info Artifact"
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)\${{ parameters.artifactName }}.txt'
      ArtifactName: '${{ parameters.artifactName }}'
