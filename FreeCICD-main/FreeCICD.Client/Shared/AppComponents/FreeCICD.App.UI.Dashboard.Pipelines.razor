@* Pipeline Dashboard Component *@
@* Displays a list of Azure DevOps pipelines with filtering, sorting, grouping, and Card/Table views *@

@implements IDisposable
@using Humanizer
@inject BlazorDataModel Model
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime

@code {
    protected bool _loadedData = false;
    protected bool _loading = true;
    protected string _pageName = "pipelines";
    protected DataObjects.PipelineDashboardResponse? _dashboardResponse;
    protected string? _errorMessage;

    // Filter state
    protected string _searchTerm = "";
    protected string _selectedStatus = "";
    protected string _selectedResult = "";
    protected string _selectedRepository = "";
    protected string _selectedTrigger = "";
    protected bool _failedOnly = false;

    // View state
    protected string _viewMode = "table";      // Changed from "card" to "table"
    protected bool _groupByFolder = false;     // Changed from true to false
    protected string _sortBy = "lastrun-desc";

    // Group expansion state - now tracks full paths for nested folders
    protected HashSet<string> _expandedGroups = [];

    // Folder node model for recursive hierarchy
    public class FolderNode
    {
        public string Name { get; set; } = "";
        public string FullPath { get; set; } = "";
        public List<FolderNode> SubFolders { get; set; } = [];
        public List<DataObjects.PipelineListItem> Pipelines { get; set; } = [];
        public int Depth { get; set; } = 0;

        // Recursively get all pipelines including subfolders
        public List<DataObjects.PipelineListItem> GetAllPipelines()
        {
            var all = new List<DataObjects.PipelineListItem>(Pipelines);
            foreach (var sub in SubFolders) {
                all.AddRange(sub.GetAllPipelines());
            }
            return all;
        }

        // Get total count including subfolders
        public int GetTotalPipelineCount()
        {
            return Pipelines.Count + SubFolders.Sum(s => s.GetTotalPipelineCount());
        }
    }

    // Computed properties
    protected List<string> AvailableRepositories => _dashboardResponse?.Pipelines?
        .Select(p => p.CodeRepoName ?? p.RepositoryName).Where(r => !string.IsNullOrWhiteSpace(r))
        
        .Distinct()
        .OrderBy(r => r)
        .ToList() ?? [];

    protected List<DataObjects.PipelineListItem> FilteredPipelines {
        get {
            if (_dashboardResponse?.Pipelines == null) return [];

            var pipelines = _dashboardResponse.Pipelines.AsEnumerable();

            // Apply search filter
            if (!string.IsNullOrWhiteSpace(_searchTerm)) {
                var search = _searchTerm.ToLower();
                pipelines = pipelines.Where(p =>
                    (p.Name?.ToLower().Contains(search) == true) ||
                    (p.CodeRepoName?.ToLower().Contains(search) == true) || (p.RepositoryName?.ToLower().Contains(search) == true) ||
                    (p.Path?.ToLower().Contains(search) == true));
            }

            // Apply status filter
            if (!string.IsNullOrWhiteSpace(_selectedStatus)) {
                pipelines = pipelines.Where(p =>
                    p.LastRunStatus?.ToLower() == _selectedStatus.ToLower());
            }

            // Apply result filter
            if (!string.IsNullOrWhiteSpace(_selectedResult)) {
                pipelines = pipelines.Where(p =>
                    p.LastRunResult?.ToLower() == _selectedResult.ToLower());
            }

            // Apply repository filter
            if (!string.IsNullOrWhiteSpace(_selectedRepository)) {
                pipelines = pipelines.Where(p =>
                    (p.CodeRepoName ?? p.RepositoryName) == _selectedRepository);
            }

            // Apply trigger filter
            if (!string.IsNullOrWhiteSpace(_selectedTrigger)) {
                pipelines = _selectedTrigger.ToLower() switch {
                    "manual" => pipelines.Where(p => p.TriggerType == DataObjects.TriggerType.Manual),
                    "codepush" => pipelines.Where(p => p.TriggerType == DataObjects.TriggerType.CodePush),
                    "scheduled" => pipelines.Where(p => p.TriggerType == DataObjects.TriggerType.Scheduled),
                    "pullrequest" => pipelines.Where(p => p.TriggerType == DataObjects.TriggerType.PullRequest),
                    "pipelinecompletion" => pipelines.Where(p => p.TriggerType == DataObjects.TriggerType.PipelineCompletion),
                    "other" => pipelines.Where(p => p.TriggerType == DataObjects.TriggerType.Other || 
                                                    p.TriggerType == DataObjects.TriggerType.ResourceTrigger),
                    _ => pipelines
                };
            }

            // Apply failed only filter
            if (_failedOnly) {
                pipelines = pipelines.Where(p =>
                    p.LastRunResult?.ToLower() == "failed");
            }

            // Apply sorting
            pipelines = _sortBy switch {
                "name-asc" => pipelines.OrderBy(p => p.Name),
                "name-desc" => pipelines.OrderByDescending(p => p.Name),
                "lastrun-desc" => pipelines.OrderByDescending(p => p.LastRunTime ?? DateTime.MinValue),
                "lastrun-asc" => pipelines.OrderBy(p => p.LastRunTime ?? DateTime.MinValue),
                "status-failed" => pipelines.OrderByDescending(p => p.LastRunResult?.ToLower() == "failed")
                    .ThenBy(p => p.Name),
                "status-success" => pipelines.OrderByDescending(p => p.LastRunResult?.ToLower() == "succeeded")
                    .ThenBy(p => p.Name),
                "trigger-type" => pipelines.OrderBy(p => (int)p.TriggerType)
                    .ThenBy(p => p.Name),
                "trigger-manual" => pipelines.OrderByDescending(p => p.TriggerType == DataObjects.TriggerType.Manual)
                    .ThenBy(p => (int)p.TriggerType)
                    .ThenBy(p => p.Name),
                "trigger-automated" => pipelines.OrderByDescending(p => p.IsAutomatedTrigger)
                    .ThenBy(p => (int)p.TriggerType)
                    .ThenBy(p => p.Name),
                // Duration sorting (nulls go to end)
                "duration-desc" => pipelines.OrderByDescending(p => p.Duration ?? TimeSpan.Zero),
                "duration-asc" => pipelines.OrderBy(p => p.Duration ?? TimeSpan.MaxValue),
                // Branch sorting
                "branch-asc" => pipelines.OrderBy(p => p.CodeBranch ?? p.TriggerBranch ?? p.DefaultBranch ?? ""),
                "branch-desc" => pipelines.OrderByDescending(p => p.CodeBranch ?? p.TriggerBranch ?? p.DefaultBranch ?? ""),
                // Repository sorting
                "repository-asc" => pipelines.OrderBy(p => p.CodeRepoName ?? p.RepositoryName ?? ""),
                "repository-desc" => pipelines.OrderByDescending(p => p.CodeRepoName ?? p.RepositoryName ?? ""),
                _ => pipelines.OrderByDescending(p => p.LastRunTime ?? DateTime.MinValue)
            };

            return pipelines.ToList();
        }
    }

    // Build hierarchical folder structure from filtered pipelines
    protected List<FolderNode> RootFolders {
        get {
            return BuildFolderHierarchy(FilteredPipelines);
        }
    }

    protected List<FolderNode> BuildFolderHierarchy(List<DataObjects.PipelineListItem> pipelines)
    {
        var rootNodes = new Dictionary<string, FolderNode>();

        foreach (var pipeline in pipelines) {
            var path = pipeline.Path?.TrimStart('\\', '/') ?? "";
            var segments = path.Split(['\\', '/'], StringSplitOptions.RemoveEmptyEntries);

            if (segments.Length == 0) {
                // Pipeline is at root level - use "Uncategorized"
                if (!rootNodes.TryGetValue("Uncategorized", out var uncatNode)) {
                    uncatNode = new FolderNode {
                        Name = "Uncategorized",
                        FullPath = "Uncategorized",
                        Depth = 0
                    };
                    rootNodes["Uncategorized"] = uncatNode;
                }
                uncatNode.Pipelines.Add(pipeline);
            } else {
                // Navigate/create folder hierarchy
                var rootName = segments[0];
                if (!rootNodes.TryGetValue(rootName, out var currentNode)) {
                    currentNode = new FolderNode {
                        Name = rootName,
                        FullPath = rootName,
                        Depth = 0
                    };
                    rootNodes[rootName] = currentNode;
                }

                // Navigate through remaining segments
                for (int i = 1; i < segments.Length; i++) {
                    var segmentName = segments[i];
                    var fullPath = string.Join("/", segments.Take(i + 1));
                    
                    var childNode = currentNode.SubFolders.FirstOrDefault(s => s.Name == segmentName);
                    if (childNode == null) {
                        childNode = new FolderNode {
                            Name = segmentName,
                            FullPath = fullPath,
                            Depth = i
                        };
                        currentNode.SubFolders.Add(childNode);
                    }
                    currentNode = childNode;
                }

                // Add pipeline to the deepest folder
                currentNode.Pipelines.Add(pipeline);
            }
        }

        // Sort folders and their subfolders recursively
        var result = rootNodes.Values.OrderBy(f => f.Name).ToList();
        SortFoldersRecursively(result);
        return result;
    }

    protected void SortFoldersRecursively(List<FolderNode> folders)
    {
        foreach (var folder in folders) {
            folder.SubFolders = folder.SubFolders.OrderBy(s => s.Name).ToList();
            folder.Pipelines = folder.Pipelines.OrderBy(p => p.Name).ToList();
            SortFoldersRecursively(folder.SubFolders);
        }
    }

    protected Dictionary<string, List<DataObjects.PipelineListItem>> GroupedPipelines {
        get {
            var filtered = FilteredPipelines;
            if (!_groupByFolder) {
                return new Dictionary<string, List<DataObjects.PipelineListItem>> {
                    { "All Pipelines", filtered }
                };
            }

            return filtered
                .GroupBy(p => GetFolderName(p.Path))
                .OrderBy(g => g.Key)
                .ToDictionary(g => g.Key, g => g.ToList());
        }
    }

    // Progressive loading state
    protected int _loadedCount = 0;
    protected int _totalCount = 0;
    protected bool _isProgressiveLoading = false;
    protected string _loadingMessage = "Loading pipelines...";

    public void Dispose()
    {
        Model.OnChange -= OnDataModelUpdated;
        Model.OnSignalRUpdate -= OnSignalRUpdate;
    }

    protected override void OnInitialized()
    {
        Model.OnChange += OnDataModelUpdated;
        Model.OnSignalRUpdate += OnSignalRUpdate;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender) {
            await LoadPreferences();
        }

        if (Model.Loaded && Model.LoggedIn) {
            if (!_loadedData) {
                _loadedData = true;
                await LoadDashboardData();
            }
        }
    }

    /// <summary>
    /// Handles SignalR updates for progressive dashboard loading.
    /// </summary>
    protected void OnSignalRUpdate(DataObjects.SignalRUpdate update)
    {
        if (update == null) return;

        switch (update.UpdateType) {
            case DataObjects.SignalRUpdateType.DashboardPipelinesSkeleton:
                // Received skeleton - show placeholder cards immediately
                HandleSkeletonUpdate(update);
                break;

            case DataObjects.SignalRUpdateType.DashboardPipelineBatch:
                // Received enriched batch - update existing items
                HandleBatchUpdate(update);
                break;

            case DataObjects.SignalRUpdateType.DashboardLoadComplete:
                // Loading complete
                _isProgressiveLoading = false;
                _loading = false;
                _loadingMessage = "";
                InvokeAsync(StateHasChanged);
                break;

            case DataObjects.SignalRUpdateType.LoadingDevOpsInfoStatusUpdate:
                // Status message update
                if (!string.IsNullOrWhiteSpace(update.Message)) {
                    _loadingMessage = update.Message;
                    InvokeAsync(StateHasChanged);
                }
                break;
        }
    }

    /// <summary>
    /// Handles skeleton update - shows pipeline cards with minimal info.
    /// </summary>
    private void HandleSkeletonUpdate(DataObjects.SignalRUpdate update)
    {
        try {
            if (update.Object is System.Text.Json.JsonElement jsonElement) {
                var skeletonItems = System.Text.Json.JsonSerializer.Deserialize<List<DataObjects.PipelineListItem>>(
                    jsonElement.GetRawText(),
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                
                if (skeletonItems != null) {
                    _dashboardResponse ??= new DataObjects.PipelineDashboardResponse();
                    
                    // Handle "connecting" state (empty list) vs actual skeleton
                    if (skeletonItems.Count == 0) {
                        // First signal - just show we're connecting
                        _isProgressiveLoading = true;
                        _loading = false;
                        _loadingMessage = update.Message ?? "Connecting to Azure DevOps...";
                        _totalCount = 0;
                        _loadedCount = 0;
                    } else {
                        // Actual skeleton with pipeline names
                        _dashboardResponse.Pipelines = skeletonItems;
                        _dashboardResponse.TotalCount = skeletonItems.Count;
                        _totalCount = skeletonItems.Count;
                        _loadedCount = 0;
                        _isProgressiveLoading = true;
                        _loading = false;
                        _loadingMessage = update.Message ?? $"Found {skeletonItems.Count} pipelines";
                        InitializeExpandedGroups();
                    }
                    InvokeAsync(StateHasChanged);
                }
            }
        } catch {
            // Ignore deserialization errors
        }
    }

    /// <summary>
    /// Handles batch update - updates existing pipeline items with enriched data.
    /// </summary>
    private void HandleBatchUpdate(DataObjects.SignalRUpdate update)
    {
        try {
            if (update.Object is System.Text.Json.JsonElement jsonElement) {
                var batchItems = System.Text.Json.JsonSerializer.Deserialize<List<DataObjects.PipelineListItem>>(
                    jsonElement.GetRawText(),
                    new System.Text.Json.JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                
                if (batchItems != null && _dashboardResponse?.Pipelines != null) {
                    foreach (var enrichedItem in batchItems) {
                        var existingItem = _dashboardResponse.Pipelines.FirstOrDefault(p => p.Id == enrichedItem.Id);
                        if (existingItem != null) {
                            // Update existing item with enriched data
                            var index = _dashboardResponse.Pipelines.IndexOf(existingItem);
                            _dashboardResponse.Pipelines[index] = enrichedItem;
                        }
                    }
                    _loadedCount += batchItems.Count;
                    _loadingMessage = update.Message ?? $"Loaded {_loadedCount} of {_totalCount} pipelines";
                    InvokeAsync(StateHasChanged);
                }
            }
        } catch {
            // Ignore deserialization errors
        }
    }

    protected void OnDataModelUpdated()
    {
        if (Model.View == _pageName) {
            StateHasChanged();
        }
    }

    protected async Task LoadDashboardData()
    {
        _loading = true;
        _errorMessage = null;
        StateHasChanged();

        try {
            var response = await Helpers.GetOrPost<DataObjects.PipelineDashboardResponse>(
                DataObjects.Endpoints.PipelineDashboard.GetPipelinesList +
                "?connectionId=" + Uri.EscapeDataString((string.Empty + Model?.SignalrClientRegistration?.ConnectionId).Trim()));

            if (response != null) {
                _dashboardResponse = response;
                if (!response.Success && !string.IsNullOrWhiteSpace(response.ErrorMessage)) {
                    _errorMessage = response.ErrorMessage;
                }
                // Initialize all groups as expanded
                InitializeExpandedGroups();
            } else {
                _errorMessage = "Failed to load pipelines. Please try again.";
            }
        } catch (Exception ex) {
            _errorMessage = $"Error loading pipelines: {ex.Message}";
        } finally {
            _loading = false;
            StateHasChanged();
        }
    }

    protected void InitializeExpandedGroups()
    {
        _expandedGroups.Clear();
        // Expand all folders recursively
        ExpandFoldersRecursively(RootFolders);
    }

    protected void ExpandFoldersRecursively(List<FolderNode> folders)
    {
        foreach (var folder in folders) {
            _expandedGroups.Add(folder.FullPath);
            ExpandFoldersRecursively(folder.SubFolders);
        }
    }

    protected async Task RefreshDashboard()
    {
        _loadedData = false;
        _isProgressiveLoading = false;
        _loadedCount = 0;
        _totalCount = 0;
        _loadingMessage = "Loading pipelines...";
        await LoadDashboardData();
    }

    protected void NavigateToWizard()
    {
        Navigation.NavigateTo(Helpers.BuildUrl("Wizard"));
    }

    protected void NavigateToWizardWithImport(int pipelineId)
    {
        Navigation.NavigateTo(Helpers.BuildUrl("Wizard") + "?import=" + pipelineId);
    }

    protected void OpenInAzureDevOps(string? url)
    {
        if (!string.IsNullOrWhiteSpace(url)) {
            Navigation.NavigateTo(url, true);
        }
    }

    protected void OnEditPipeline(DataObjects.PipelineListItem pipeline)
    {
        NavigateToWizardWithImport(pipeline.Id);
    }

    protected void OnViewPipeline(DataObjects.PipelineListItem pipeline)
    {
        OpenInAzureDevOps(pipeline.ResourceUrl);
    }

    /// <summary>
    /// Copies pipeline YAML to clipboard.
    /// </summary>
    protected async Task OnCopyYaml(DataObjects.PipelineListItem pipeline)
    {
        try {
            // Fetch the YAML content
            var request = new DataObjects.PipelineYamlRequest {
                PipelineId = pipeline.Id
            };
            
            var response = await Helpers.GetOrPost<DataObjects.PipelineYamlResponse>(
                DataObjects.Endpoints.PipelineDashboard.GetPipelineYaml.Replace("{id}", pipeline.Id.ToString()));
            
            if (response?.Success == true && !string.IsNullOrWhiteSpace(response.Yaml)) {
                await Helpers.CopyToClipboard(response.Yaml);
                Model.AddMessage($"YAML for '{pipeline.Name}' copied to clipboard!", MessageType.Success);
            } else {
                Model.AddMessage(response?.ErrorMessage ?? "Failed to fetch YAML content.", MessageType.Danger);
            }
        } catch (Exception ex) {
            Model.AddMessage($"Error copying YAML: {ex.Message}", MessageType.Danger);
        }
    }

    // Filter/Sort/View handlers
    protected void OnFiltersUpdated()
    {
        StateHasChanged();
        _ = SavePreferences();
    }

    protected void OnViewModeChanged(string mode)
    {
        _viewMode = mode;
        StateHasChanged();
        _ = SavePreferences();
    }

    protected void OnGroupByFolderChanged(bool groupBy)
    {
        _groupByFolder = groupBy;
        if (groupBy) {
            InitializeExpandedGroups();
        }
        StateHasChanged();
        _ = SavePreferences();
    }

    protected void OnSortByChanged(string sortBy)
    {
        _sortBy = sortBy;
        StateHasChanged();
        _ = SavePreferences();
    }

    // Handle sort changes from table column clicks
    protected void OnTableSortChanged((string Column, bool Ascending) sort)
    {
        // Map column name to dropdown value
        _sortBy = (sort.Column, sort.Ascending) switch {
            ("name", true) => "name-asc",
            ("name", false) => "name-desc",
            ("lastrun", true) => "lastrun-asc",
            ("lastrun", false) => "lastrun-desc",
            ("status", true) => "status-success",
            ("status", false) => "status-failed",
            ("trigger", true) => "trigger-manual",
            ("trigger", false) => "trigger-automated",
            // Duration sorting
            ("duration", true) => "duration-asc",
            ("duration", false) => "duration-desc",
            // Branch sorting
            ("branch", true) => "branch-asc",
            ("branch", false) => "branch-desc",
            // Repository sorting
            ("repository", true) => "repository-asc",
            ("repository", false) => "repository-desc",
            _ => _sortBy
        };
        StateHasChanged();
        _ = SavePreferences();
    }

    // Get current sort column for table view
    protected string GetCurrentSortColumn()
    {
        return _sortBy switch {
            "name-asc" or "name-desc" => "name",
            "lastrun-asc" or "lastrun-desc" => "lastrun",
            "status-failed" or "status-success" => "status",
            "trigger-type" or "trigger-manual" or "trigger-automated" => "trigger",
            "duration-asc" or "duration-desc" => "duration",
            "branch-asc" or "branch-desc" => "branch",
            "repository-asc" or "repository-desc" => "repository",
            _ => "lastrun"
        };
    }

    // Get current sort direction for table view
    protected bool GetCurrentSortAscending()
    {
        return _sortBy switch {
            "name-asc" => true,
            "name-desc" => false,
            "lastrun-asc" => true,
            "lastrun-desc" => false,
            "status-success" => true,
            "status-failed" => false,
            "trigger-manual" => true,
            "trigger-automated" or "trigger-type" => false,
            "duration-asc" => true,
            "duration-desc" => false,
            "branch-asc" => true,
            "branch-desc" => false,
            "repository-asc" => true,
            "repository-desc" => false,
            _ => false
        };
    }

    protected void OnExpandAll()
    {
        InitializeExpandedGroups();
        StateHasChanged();
    }

    protected void OnCollapseAll()
    {
        _expandedGroups.Clear();
        StateHasChanged();
    }

    protected void OnGroupExpandedChanged(string groupName, bool isExpanded)
    {
        if (isExpanded) {
            _expandedGroups.Add(groupName);
        } else {
            _expandedGroups.Remove(groupName);
        }
    }

    // Helper methods
    protected string GetFolderName(string? path)
    {
        if (string.IsNullOrWhiteSpace(path)) return "Uncategorized";
        
        // Remove leading backslash and get first folder segment
        var cleanPath = path.TrimStart('\\', '/');
        var segments = cleanPath.Split(['\\', '/'], StringSplitOptions.RemoveEmptyEntries);
        
        return segments.Length > 0 ? segments[0] : "Uncategorized";
    }

    protected (int succeeded, int failed, int partial, int running, int queued) GetGroupStats(List<DataObjects.PipelineListItem> pipelines)
    {
        int succeeded = 0, failed = 0, partial = 0, running = 0, queued = 0;

        foreach (var p in pipelines) {
            var status = p.LastRunStatus?.ToLower() ?? "";
            var result = p.LastRunResult?.ToLower() ?? "";

            if (status == "inprogress" || status == "running") {
                running++;
            } else if (status == "notstarted" || status == "queued") {
                queued++;
            } else if (status == "completed" || status == "finished") {
                switch (result) {
                    case "succeeded": succeeded++; break;
                    case "failed": failed++; break;
                    case "partiallysucceeded": partial++; break;
                }
            }
        }

        return (succeeded, failed, partial, running, queued);
    }

    // Get stats for a folder node including all nested subfolders
    protected (int succeeded, int failed, int partial, int running, int queued) GetFolderStats(FolderNode folder)
    {
        return GetGroupStats(folder.GetAllPipelines());
    }

    // localStorage persistence
    protected async Task LoadPreferences()
    {
        try {
            var prefs = await JSRuntime.InvokeAsync<PipelineDashboardPreferences?>("localStorage.getItem", "pipelineDashboardPrefs");
            if (prefs != null) {
                _viewMode = prefs.ViewMode ?? "card";
                _groupByFolder = prefs.GroupByFolder;
                _sortBy = prefs.SortBy ?? "lastrun-desc";
            }
        } catch {
            // Ignore localStorage errors
        }
    }

    protected async Task SavePreferences()
    {
        try {
            var prefs = new PipelineDashboardPreferences {
                ViewMode = _viewMode,
                GroupByFolder = _groupByFolder,
                SortBy = _sortBy
            };
            var json = System.Text.Json.JsonSerializer.Serialize(prefs);
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "pipelineDashboardPrefs", json);
        } catch {
            // Ignore localStorage errors
        }
    }

    public class PipelineDashboardPreferences
    {
        public string? ViewMode { get; set; }
        public bool GroupByFolder { get; set; }
        public string? SortBy { get; set; }
    }
}

@if (Model.Loaded && Model.LoggedIn && Model.View == _pageName) {
    <div class="container-fluid px-0" style="max-width: 1400px;">
        @* Page Header *@
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1 class="page-title mb-0">
                <i class="fa fa-rocket me-2"></i>
                Pipeline Dashboard
            </h1>
            <div class="d-flex gap-2">
                <button class="btn btn-outline-secondary" @onclick="RefreshDashboard" disabled="@(_loading || _isProgressiveLoading)">
                    <i class="fa fa-refresh @((_loading || _isProgressiveLoading) ? "fa-spin" : "")"></i>
                    Refresh
                </button>
                <button class="btn btn-primary" @onclick="NavigateToWizard">
                    <i class="fa fa-plus me-1"></i>
                    Create Pipeline
                </button>
            </div>
        </div>

        @* Progressive Loading Banner *@
        @if (_isProgressiveLoading) {
            <div class="alert alert-info d-flex align-items-center mb-3" role="alert">
                <div class="spinner-border spinner-border-sm me-2" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <div class="flex-grow-1">
                    @_loadingMessage
                </div>
                @if (_totalCount > 0) {
                    <div class="ms-3">
                        <div class="progress" style="width: 150px; height: 8px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" 
                                 style="width: @((_loadedCount * 100 / _totalCount))%"
                                 aria-valuenow="@_loadedCount" 
                                 aria-valuemin="0" 
                                 aria-valuemax="@_totalCount">
                            </div>
                        </div>
                    </div>
                }
            </div>
        }

        @* Loading State (only when no progressive updates yet) *@
        @if (_loading && !_isProgressiveLoading) {
            <div class="d-flex flex-column justify-content-center align-items-center my-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <div class="mt-3 text-muted">@_loadingMessage</div>
            </div>
        }
        @* Error State *@
        else if (!string.IsNullOrWhiteSpace(_errorMessage) && !_isProgressiveLoading) {
            <div class="alert alert-danger" role="alert">
                <i class="fa fa-exclamation-triangle me-2"></i>
                @_errorMessage
                <button class="btn btn-sm btn-outline-danger ms-3" @onclick="RefreshDashboard">
                    Try Again
                </button>
            </div>
        }
        @* Content - show when we have pipelines OR during progressive loading with pipelines *@
        @if ((_dashboardResponse?.Pipelines?.Any() == true) || (!_loading && !_isProgressiveLoading && string.IsNullOrWhiteSpace(_errorMessage))) {
            @* Filter Bar *@
            <FreeCICD_App_UI_Dashboard_FilterBar
                SearchTerm="@_searchTerm"
                SearchTermChanged="@(val => { _searchTerm = val; StateHasChanged(); })"
                SelectedStatus="@_selectedStatus"
                SelectedStatusChanged="@(val => _selectedStatus = val)"
                SelectedResult="@_selectedResult"
                SelectedResultChanged="@(val => _selectedResult = val)"
                SelectedRepository="@_selectedRepository"
                SelectedRepositoryChanged="@(val => _selectedRepository = val)"
                SelectedTrigger="@_selectedTrigger"
                SelectedTriggerChanged="@(val => _selectedTrigger = val)"
                FailedOnly="@_failedOnly"
                FailedOnlyChanged="@(val => _failedOnly = val)"
                Repositories="@AvailableRepositories"
                OnFiltersUpdated="@OnFiltersUpdated" />

            @* View Controls *@
            <FreeCICD_App_UI_Dashboard_ViewControls
                ViewMode="@_viewMode"
                ViewModeChanged="@OnViewModeChanged"
                GroupByFolder="@_groupByFolder"
                GroupByFolderChanged="@OnGroupByFolderChanged"
                SortBy="@_sortBy"
                SortByChanged="@OnSortByChanged"
                ExpandAllRequested="@OnExpandAll"
                CollapseAllRequested="@OnCollapseAll" />

            @* Empty State (after filtering) *@
            @if (!FilteredPipelines.Any()) {
                <div class="card shadow-sm border-0">
                    <div class="card-body text-center py-5">
                        @if (_dashboardResponse?.Pipelines?.Any() == true) {
                            <i class="fa fa-filter fa-3x text-muted mb-3"></i>
                            <h4 class="text-muted">No Matching Pipelines</h4>
                            <p class="text-muted mb-4">Try adjusting your filters or search term.</p>
                        } else {
                            <i class="fa fa-folder-open fa-3x text-muted mb-3"></i>
                            <h4 class="text-muted">No Pipelines Found</h4>
                            <p class="text-muted mb-4">Get started by creating your first pipeline.</p>
                            <button class="btn btn-primary btn-lg" @onclick="NavigateToWizard">
                                <i class="fa fa-plus me-2"></i>
                                Create Your First Pipeline
                            </button>
                        }
                    </div>
                </div>
            }
            @* Grouped View - Now uses recursive folder hierarchy *@
            else if (_groupByFolder) {
                @foreach (var folder in RootFolders) {
                    @RenderFolderNode(folder)
                }
            }
            @* Flat View (no grouping) *@
            else {
                @if (_viewMode == "card") {
                    <div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 row-cols-xl-4 g-4">
                        @foreach (var pipeline in FilteredPipelines) {
                            <div class="col">
                                <FreeCICD_App_UI_Dashboard_PipelineCard Pipeline="@pipeline"
                                    OnEdit="@(() => OnEditPipeline(pipeline))"
                                    OnView="@(() => OnViewPipeline(pipeline))"
                                    OnCopyYaml="@OnCopyYaml" />
                            </div>
                        }
                    </div>
                } else {
                    <div class="card shadow-sm border-0">
                        <div class="card-body p-0">
                            <FreeCICD_App_UI_Dashboard_TableView
                                Pipelines="@FilteredPipelines"
                                SortColumn="@GetCurrentSortColumn()"
                                SortAscending="@GetCurrentSortAscending()"
                                OnSortChanged="@OnTableSortChanged"
                                OnEdit="@OnEditPipeline"
                                OnView="@OnViewPipeline"
                                OnCopyYaml="@OnCopyYaml" />
                        </div>
                    </div>
                }
            }

            @* Summary Footer *@
            <div class="mt-4 d-flex justify-content-between align-items-center text-muted small">
                <div>
                    Showing @FilteredPipelines.Count
                    @if (_dashboardResponse?.Pipelines?.Count != FilteredPipelines.Count) {
                        <span>of @(_dashboardResponse?.Pipelines?.Count ?? 0)</span>
                    }
                    pipeline(s)
                    @if (_groupByFolder && RootFolders.Count > 1) {
                        <span>in @RootFolders.Count folders</span>
                    }
                </div>
                <div>
                    @{
                        var allStats = GetGroupStats(FilteredPipelines);
                    }
                    @if (allStats.succeeded > 0) {
                        <span class="me-2"><i class="fa fa-check text-success me-1"></i>@allStats.succeeded</span>
                    }
                    @if (allStats.failed > 0) {
                        <span class="me-2"><i class="fa fa-times text-danger me-1"></i>@allStats.failed</span>
                    }
                    @if (allStats.partial > 0) {
                        <span class="me-2"><i class="fa fa-exclamation-triangle text-warning me-1"></i>@allStats.partial</span>
                    }
                    @if (allStats.running > 0) {
                        <span class="me-2"><i class="fa fa-spinner fa-spin text-info me-1"></i>@allStats.running</span>
                    }
                </div>
            </div>
        }
    </div>
}

@code {
    // Render a folder node recursively
    private RenderFragment RenderFolderNode(FolderNode folder) => __builder =>
    {
        var stats = GetFolderStats(folder);
        var isExpanded = _expandedGroups.Contains(folder.FullPath);
        var totalCount = folder.GetTotalPipelineCount();

        <FreeCICD_App_UI_Dashboard_PipelineGroup
            GroupId="@folder.FullPath.Replace(" ", "-").Replace("/", "-").ToLower()"
            GroupName="@folder.Name"
            PipelineCount="@totalCount"
            SucceededCount="@stats.succeeded"
            FailedCount="@stats.failed"
            PartialCount="@stats.partial"
            RunningCount="@stats.running"
            QueuedCount="@stats.queued"
            IsExpanded="@isExpanded"
            IsExpandedChanged="@(expanded => OnGroupExpandedChanged(folder.FullPath, expanded))"
            Depth="@folder.Depth">

            @* Render subfolders first *@
            @foreach (var subFolder in folder.SubFolders) {
                @RenderFolderNode(subFolder)
            }

            @* Then render pipelines in this folder *@
            @if (folder.Pipelines.Any()) {
                @if (_viewMode == "card") {
                    <div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 row-cols-xl-4 g-3 @(folder.SubFolders.Any() ? "mt-2" : "")">
                        @foreach (var pipeline in folder.Pipelines) {
                            <div class="col">
                                <FreeCICD_App_UI_Dashboard_PipelineCard Pipeline="@pipeline"
                                    OnEdit="@(() => OnEditPipeline(pipeline))"
                                    OnView="@(() => OnViewPipeline(pipeline))"
                                    OnCopyYaml="@OnCopyYaml" />
                            </div>
                        }
                    </div>
                } else {
                    <div class="@(folder.SubFolders.Any() ? "mt-2" : "")">
                        <FreeCICD_App_UI_Dashboard_TableView
                            Pipelines="@folder.Pipelines"
                            SortColumn="@GetCurrentSortColumn()"
                            SortAscending="@GetCurrentSortAscending()"
                            OnSortChanged="@OnTableSortChanged"
                            OnEdit="@OnEditPipeline"
                            OnView="@OnViewPipeline"
                            OnCopyYaml="@OnCopyYaml" />
                    </div>
                }
            }
        </FreeCICD_App_UI_Dashboard_PipelineGroup>
    };
}
