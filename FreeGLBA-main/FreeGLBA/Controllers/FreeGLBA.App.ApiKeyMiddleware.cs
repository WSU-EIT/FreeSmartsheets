using System.Security.Cryptography;
using System.Text;
using Microsoft.EntityFrameworkCore;

namespace FreeGLBA.Middleware;

// ============================================================================
// API KEY AUTHENTICATION MIDDLEWARE
// Validates Bearer token for external API endpoints.
// Generated by FreeManager for template: FreeAudit
// ============================================================================

public class ApiKeyMiddleware
{
    private readonly RequestDelegate _next;

    public ApiKeyMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context, IDataAccess da)
    {
        // Only apply to external API paths that need API key auth
        // POST /api/glba/events - external event submission
        // POST /api/glba/events/batch - external batch submission
        // GET requests to /api/glba/* are internal and use user auth
        var path = context.Request.Path.Value ?? "";
        var method = context.Request.Method;

        // Only intercept POST requests to the events endpoint
        // GET requests (like /api/glba/events/recent) use [Authorize] user auth
        var requiresApiKey = method.Equals("POST", StringComparison.OrdinalIgnoreCase) &&
                             (path.Equals("/api/glba/events", StringComparison.OrdinalIgnoreCase) ||
                              path.Equals("/api/glba/events/batch", StringComparison.OrdinalIgnoreCase));

        if (!requiresApiKey)
        {
            await _next(context);
            return;
        }

        // Extract API key from Authorization header
        if (!context.Request.Headers.TryGetValue("Authorization", out var authHeader))
        {
            await WriteUnauthorized(context, "missing_api_key", "Authorization header required");
            return;
        }

        var headerValue = authHeader.ToString();
        if (!headerValue.StartsWith("Bearer ", StringComparison.OrdinalIgnoreCase))
        {
            await WriteUnauthorized(context, "invalid_format", "Authorization header must use Bearer scheme");
            return;
        }

        var apiKey = headerValue.Substring(7).Trim();
        if (string.IsNullOrEmpty(apiKey))
        {
            await WriteUnauthorized(context, "empty_api_key", "API key cannot be empty");
            return;
        }

        // Validate API key
        var source = await da.ValidateApiKeyAsync(apiKey);
        if (source == null)
        {
            await WriteUnauthorized(context, "invalid_api_key", "API key is invalid or inactive");
            return;
        }

        // Store source system in context for controller
        context.Items["SourceSystem"] = source;

        await _next(context);
    }

    private static async Task WriteUnauthorized(HttpContext context, string error, string message)
    {
        context.Response.StatusCode = 401;
        context.Response.ContentType = "application/json";
        await context.Response.WriteAsJsonAsync(new { error, message });
    }
}

// ============================================================================
// MIDDLEWARE EXTENSION
// ============================================================================

public static class ApiKeyMiddlewareExtensions
{
    public static IApplicationBuilder UseApiKeyAuth(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<ApiKeyMiddleware>();
    }
}
